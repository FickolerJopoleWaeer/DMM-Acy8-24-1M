# Poker_Player.py

import discord
from discord.ext import commands
from discord import app_commands, Interaction
from discord import ui # Диалоговое окно
from discord.ui import  Button, View
from .models.MainModels import User
from .models.PokerModels import Room
from .configs import MainConfig as MC
from .configs import PokerConfig as PC
from .embeds.MainEmbed import Embed
from .functions.MainFunction import Func
from .functions.PokerFunction import FuncP
import random

class Poker_Player(commands.GroupCog, name="покер"): # создаёт класс команд
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        super().__init__()


# 0 - начать
    '''
Покер начать:
Начинает игру: 
выводит список участников: кто ходит каким, +
называет минимальную сумму для малого блайнда, +
Карты ещё НЕ выдаёт! +
Также выводит общую информацию по текущей игре:
    вид покера, +
    тип ставок, +
    макс.ставку +
    и т.п.), *???
желает приятной игры. +
Пример: /покер начать
Возвращает ошибку, если:
•	Если ты не состоишь ни в одной комнате, +
•	Команду вводит не создатель комнаты (отображать создателя в командах с таким разрешением / уровнем доступа), +
•	Уже идёт игра, +
•	В комнате всего 1 человек, +
    '''
    @app_commands.command(name = "начать", description="начать игру") # balance
    async def _начало_игры(self, interaction: Interaction):
        user = User(interaction.user.id)
    # Проверяем ошибки
        Комната: str = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
        Создатель: int = room.Создатель
        if Создатель != interaction.user.id:
            await Func.error(interaction, f'Вы не являетесь создателем комнаты "{Комната}".\nЕё создатель: <@{Создатель}>.')
            return
        Текущий_раунд: str = room.Текущий_раунд
        if Текущий_раунд != 'не начата':
            await Func.error(interaction, f'Игра уже началась - текущий раунд: "{Текущий_раунд}".\nДождитесь окончания игры.')
            return
        Участники: list = room.Участники # список с ID участников
        if len(Участники) < 2:
            await Func.error(interaction, f'Для начала игры требуется наличие как минимум двух участников.')
            return
    # Перемешиваем порядок ходов и заносим в БД
        random.shuffle(Участники)
        room.update_field('Порядок_ходов', Участники)
        порядок_ходов = await FuncP.move_order(interaction, Участники) # функция для красивого вывода порядка ходов
        room.след_ход() # делаем +1 к следующему ходу (далее ходит первый)
        room.след_раунд('начало')
    # Выводим данные для отображения
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Мин_ставка: int = room.Мин_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка) # Выводит сообщение о максимальной ставке в зависимости от типа ставок
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Вы можете начинать играть',
f"Порядок ходов:\n{порядок_ходов}\n\n\
Тип ставок: {Тип_ставок}\n\
Малый блайнд: {Мин_ставка//2}\n\
Минимальная ставка (большой блайнд): {Мин_ставка}\n\
{text}\n\
\nПриятной игры!"))


# 1 - отмена
    '''
Покер отмена:
Отменяет игру, если не сделано ещё ни одного хода. Команда нужна на тот случай, если про какого-то игрока забыли или он не успел войти, и это как раз могли заметить в списке игроков при вводе команды: /покер начать. Также, например, если кто-то передумал играть.
Пример: /покер отмена
Возвращает ошибку, если:
•	Если ты не состоишь ни в одной комнате,
•	Команду вводит не создатель комнаты??? (отображать создателя в командах с таким разрешением / уровнем доступа), 
•	Игра ещё не началась,
•	Сделано 1 и более ходов.

! можно просто ввести второй раз команду: /покер начать
    '''

# 2 - малый_блайнд
    '''
Покер малый_блайнд:
Команда для первого хода в игре. Минимальная ставка, чтобы наполнить банк. 
Отображает:
    сделанную ставку малого блайнда (она же текущий банк), 
    минимальную сумму для большого блайнда, 
    говорит, кто ставит большой блайнд (ходит вторым). 
    Выводит список участников: кто ходит каким.
Операции с БД:
у игрока отнимает монеты
В банк игры добавляет монеты,
Обновляет текущую ставку,
переключает на следующий ход (большой блайнд ещё и на следующий раунд)
Пример: /покер малый_блайнд 50,
Где: 50 – сумма, обозначающая минимальный блайнд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась / уже началась, +
•	Сейчас не первый ход (указывает чей сейчас ход), +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Указанная сумма не является целым числом ИЛИ числом вообще, ИЛИ более чем в два раза меньше заданной изначально администратором суммы большого блайнда (Пусть будет фиксированной), +
•	Недостаточно монет, +
    '''
    @app_commands.command(name = "малый_блайнд", description="сделать первый ход")
    async def _малый_блайнд(self, interaction: Interaction):
        user = User(interaction.user.id)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Мин_ставка: int = room.Мин_ставка
        Ставка: int = round(Мин_ставка//2) # = большой блайнд / 2 = малый блайнд
        if not await FuncP.check_error_blind(interaction = interaction, user = user, room = room, Ставка = Ставка):
            return
        # interaction: Interaction, user: User, room: Optional[Room], Cтавка: int
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Текущий_ход: int = room.Текущий_ход
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
    # Операции с БД: вычитаем из баланса, добавляем денег в банк, переходим к следующему ходу
        user.ставка(Ставка) # Баланс проверяется в проверке ошибок FuncP.check_error (выше)
        room.след_ход()
        room.обновляем_банк(Ставка)
        room.новая_ставка(Ставка)
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ставка сделана!',
f"<@{interaction.user.id}> сделал ставку (Малый блайнд): {Ставка}\n\n\
Тип ставок - {Тип_ставок}\n\
Минимальная ставка: {Мин_ставка}\n\
Максимальная ставка: {text}\n\
\nСледувющим ходит: <@{room.Порядок_ходов[Текущий_ход]}>"))
        

# 3 - большой_блайнд
    '''
Покер большой_блайнд:
Команда для второго хода в игре. Ещё одна ставка, чтобы наполнить банк. 
Отображает сделанную ставку большого блайнда, +
суммирует с малым – показывает банк, +
Раздаёт по две карты игрокам, +
Урезаем колоду карт, +
Обновляет текущую ставку, +
уведомляет о том, что они могут использовать команду /покер рука – для просмотра карт в руке. +
Говорит, кто ходит третьим. +
Меняет название «начало игры» на раунд «Пре-флоп (Pre-Flop)». +
В БД делает запись о том, что началась по сути игра, раунд Пре-флоп, +
Пример: /покер большой_блайнд 50,
Где: 50 – сумма, обозначающая минимальный блайнд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не второй ход (указывает чей сейчас ход), +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Указанная сумма не является целым числом ИЛИ числом вообще, ИЛИ не больше или равна малому блайнду (заданного на первом ходе) умноженного на два (Пусть будет фиксированной), +
•	Недостаточно монет, +
    '''
    @app_commands.command(name = "большой_блайнд", description="сделать второй ход")
    async def _большой_блайнд(self, interaction: Interaction):
        user = User(interaction.user.id)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Ставка: int = room.Мин_ставка # = большому блайнду
        if not await FuncP.check_error_blind(interaction, user, room = room, Ставка = Ставка):
            return
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Текущий_ход: int = room.Текущий_ход
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
    # Операции с БД: вычитаем из баланса, добавляем денег в банк, переходим к следующему ходу
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.след_ход()             # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.новая_ставка(Ставка)   # изменяем Текущую ставку ('Текущая_ставка')
        room.след_раунд('пре-флоп') # ставки игроков при этом не обнуляем (именно на первом кругу), просто меняем название раунда
    # Раздаём по 2 карты игрокам
        Колода: list[list] = PC.Колода
        random.shuffle(Колода) # Перемешиваем колоду
        Порядок_ходов = room.Порядок_ходов
        for ID in Порядок_ходов: # Цикл раздачи карт
            player = User(ID)  # Получаем объект игрока
            карты: list[list] = [Колода.pop(), Колода.pop()]  # Убираем две карты из колоды и даём их игроку
            player.установить('Карты', карты) # Сохраняем карты игрока у него в БД
            print(f"Игрок {ID} получил карты: {карты}") # Для отладки, можно вывести, кому какие карты разданы
        room.обновляем_колоду(Колода) # фиксируем колоду в БД комнаты
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ставка сделана!',
f"<@{interaction.user.id}> сделал ставку (Большой блайнд): {Ставка}\n\n\
Тип ставок - {Тип_ставок}\n\
Минимальная ставка: {Ставка}\n\
Максимальная ставка: {text}\n\
Банк: {room.Банк_общий}\n\
\nРаунд обновлён: начало -> пре-флоп\n\
Следувющим ходит: <@{room.Порядок_ходов[Текущий_ход]}>\n\
\nПодсказка:\n\
Вам раздали карты! Используйте команду /покер рука – для просмотра карт в руке."))






    '''
Команды для самой игры:
*Каждая такая команда: 
•	выводит действие текущего игрока,  
•	тип ставок,
•	текущую ставку (как минимальную),
•	максимальную ставку (если есть),
•	обновляет список (очерёдность хода), 
•	отображает текущий раунд, 
•	сумму монет/фишек в банке (всего и в текущем раунде),
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, + 
•	добавляет карты на стол +
•	В конце игры – вызывает меню победителей.
Выдаёт ошибку, если:
•	Игра ещё не началась, (ТОЛЬКО fold - позволяет ливнуть тем, кто делает малый и большой блайнд в первые пару ходов (пока игра со статусом "началась"))
•	Ты не состоишь ни в одной комнате,
•	Сейчас не твой ход,

У некоторых:
СТАВКА не может быть больше максимальной (считать в зависимости от типа ставок - отдельную функцию для этого сделать)
    '''

# 4 - Чек
    '''
Чек (Check):
Если никто не делал ставок, игрок может пропустить ход, не вкладывая деньги в банк. (т.е. если поставленная сумма до тебя равна твоей ставке)
На префлопе сделать чек может только большой блайнд, и то если до этого не повышали ставку.
Пример: /покер чек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Ещё раунд пре-флоп, а ты не большой блайнд (не ходишь вторым), + 
•	Ставку до тебя повысили, +
    '''
    @app_commands.command(name = "чек", description="пропустить ход")
    async def _чек(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер']):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # Проверка остальных ошибок:
        Текущий_раунд: str = room.Текущий_раунд
        Порядок_ходов: list[int] = room.Порядок_ходов
        if (Текущий_раунд == 'пре-флоп') and (ID != Порядок_ходов[1]):
            await Func.error(interaction, f'На префлопе сделать чек может только большой блайнд (второй игрок): <@{Порядок_ходов[1]}>')
            return False
        Текущая_ставка = room.Текущая_ставка
        Сейчас_поставил = user.Сейчас_поставил
        if  (Сейчас_поставил != Текущая_ставка):
            await Func.error(interaction, f'До твоего хода ставку повысили.\nТекущая ставка: {Текущая_ставка}.\nТы уже поставил: {Сейчас_поставил}.\nНе хватает: {Текущая_ставка-Сейчас_поставил}\nИспользуй "/покер колл", чтобы уровнять ставку.')
            return False
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        обновление_раунда: str = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: переходим к следующему ходу и, при необходимости, к следующему раунду
        # Раунды: list[str] = PC.Раунды
        Текущий_ход: int = room.Текущий_ход
        room.след_ход()     # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        Следующий_ход : int = room.Текущий_ход
        if Следующий_ход == 1: # если номер этого хода был вторым (ходил большой блайнд), то обновляем раунд
            обновление_раунда: str = FuncP.обновить_раунд(interaction, room)
            '''
            if Текущий_раунд in Раунды:  # проверяем, есть ли название текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
                индекс = Раунды.index(Текущий_раунд) # индекс = номеру текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
                if индекс < len(Раунды) - 1: # Проверяем, есть ли следующий раунд или уже конец игры
                    Следующий_раунд: str = Раунды[индекс + 1]
                    обновление_раунда = f'Раунд обновлён: {Текущий_раунд} -> {Следующий_раунд}\n'
                    room.след_раунд(Следующий_раунд)    # меняем название раунда на слеующее
                    room.обнуляем_банк()                # 'Банк_раунда' = 0
                    room.сбросить_ставки()              # для каждого игрока обнуляем поле 'Сейчас_поставил' (в этом раунде)
                    print('обновление_раунда:', f'{Текущий_раунд} -> {Следующий_раунд}')
                # Выдаём карту на стол
                    Колода: list[list] = []
                    print('Следующий_раунд: ', Следующий_раунд)
                    if Следующий_раунд == 'флоп': # если переходим на раунд флоп, то раздём 3 карты
                        Колода = PC.Колода
                        Карты = [Колода.pop(), Колода.pop(), Колода.pop()]
                        room.стол_раздать(Карты)    # устанавливаем три карты для стола ("Карты_стола")
                        print('Карты 1: ', Карты)
                    elif Следующий_раунд in ['тёрн', 'ривер']: # при переходе к этим раундам выдаёт 1 карту.
                        Колода = room.Колода
                        Карты = [Колода.pop()] # сохраняет в 'Карты' последний элемент (карту) из 'Колода', и одновременно убирает его из списка колоды
                        room.стол_добавить(Карты)   # добавляем 1 карту к картам стола ("Карты_стола")
                        print('Карты 2: ', Карты)
                    else: pass
                    room.обновляем_колоду(Колода)   # уменьшаем колоду на 0, 1 или 3 карт в зависимости от условия if выше
                    print('обновляем_колоду: ', Колода)
            # Конец игры
                else: 
                    Следующий_раунд = None  # Если это последний раунд
                    # ВЫЗОВ ФУНКЦИИ ПОДСЧЁТА ПОБЕДИТЕЛЕЙ и НАГРАД

            else:
                Следующий_раунд = None  # Если текущего раунда нет в списке
            '''
        else: pass # идём дальше
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
        Карты_стола: list = room.Карты_стола
        print('Карты_стола: ', Карты_стола)
        карты_вывод: str = ''
        if Карты_стола:
            карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
            print('Карты по идее должны выводиться')
        else: pass
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{interaction.user.id}> использовал /покер чек (пропустил ход)\n\n\
Тип ставок - {Тип_ставок}\n\
Минимальная ставка: {Текущая_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следувющим ходит: <@{room.Порядок_ходов[Текущий_ход]}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))

        '''
Команды для самой игры:
*Каждая такая команда: 
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (как минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, + 
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока + - room.сбросить_ставки()
•	В конце игры – вызывает меню победителей. 

У некоторых:
СТАВКА не может быть больше максимальной (считать в зависимости от типа ставок - отдельную функцию для этого сделать)
        '''

# 5 - Колл
    '''
Колл (Call): 
Уравнивание ставки. +
Обновляем банк. +
Пример: /покер колл
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт), +
•	Ставку до тебя не повышали (рекомендует использовать Чек для пропуска хода или Бет для поднятия ставки), +
    '''
    @app_commands.command(name = "колл", description="уравнять ставку")
    async def _колл(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Текущая_ставка: int = room.Текущая_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер'], Ставка = Ставка):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход, Недостаточно монет
    # Проверка остальных ошибок:
        Текущий_раунд: str = room.Текущий_раунд
        if Ставка == 0:
            await Func.error(interaction, f'До твоего хода ставку не повышали.\nМожешь использовать "/покер чек" для пропуска хода или "/покер бет" для поднятия ставки')
            return False
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        обновление_раунда = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: делаем ставку, обновляем банк, переходим к следующему ходу и, при необходимости, к следующему раунду
        # Раунды: list[str] = PC.Раунды
        Текущий_ход: int = room.Текущий_ход
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.след_ход()     # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        Следующий_ход : int = room.Текущий_ход
        if Следующий_ход == 1: # если номер этого хода был вторым (ходил большой блайнд), то обновляем раунд
            обновление_раунда: str = FuncP.обновить_раунд(interaction, room)
            '''
            if Текущий_раунд in Раунды:  # проверяем, есть ли название текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
                индекс: int = Раунды.index(Текущий_раунд) # индекс = номеру текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
                if индекс < len(Раунды) - 1: # Проверяем, есть ли следующий раунд или уже конец игры
                    Следующий_раунд: str = Раунды[индекс + 1]
                    обновление_раунда = f'Раунд обновлён: {Текущий_раунд} -> {Следующий_раунд}\n'
                    room.след_раунд(Следующий_раунд)    # меняем название раунда на слеующее
                    room.обнуляем_банк()                # 'Банк_раунда' = 0
                    room.сбросить_ставки()              # для каждого игрока обнуляем поле 'Сейчас_поставил' (в этом раунде)
                # Выдаём карту на стол
                    Колода: list[list] = []
                    print('Следующий_раунд: ', Следующий_раунд)
                    if Следующий_раунд == 'флоп': # если переходим на раунд флоп, то раздём 3 карты
                        Колода = PC.Колода
                        Карты = [Колода.pop(), Колода.pop(), Колода.pop()]
                        room.стол_раздать(Карты)    # устанавливаем три карты для стола 
                        print('Карты 1: ', Карты)
                    elif Следующий_раунд in ['тёрн', 'ривер']: # при переходе к этим раундам выдаёт 1 карту.
                        Колода = room.Колода
                        Карты = [Колода.pop()] # сохраняет в 'Карты' последний элемент (карту) из 'Колода', и одновременно убирает его из списка колоды
                        room.стол_добавить(Карты)   # добавляем 1 карту к картам стола
                        print('Карты 2: ', Карты)
                    else: pass
                    room.обновляем_колоду(Колода)   # уменьшаем колоду на 0, 1 или 3 карт в зависимости от условия if выше
                    print('обновляем_колоду: ', Колода)
            # Конец игры
                else: 
                    Следующий_раунд = None  # Если это последний раунд
                    # ВЫЗОВ ФУНКЦИИ ПОДСЧЁТА ПОБЕДИТЕЛЕЙ и НАГРАД
            else:
                Следующий_раунд = None  # Если текущего раунда нет в списке
            '''
        else: pass # идём дальше
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
        Карты_стола = room.Карты_стола
        карты_вывод: str = ''
        if Карты_стола:
            карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
        else: pass
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{interaction.user.id}> использовал /покер колл (уравнял ставку на {Ставка})\n\n\
Тип ставок - {Тип_ставок}\n\
Минимальная ставка: {Текущая_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следувющим ходит: <@{room.Порядок_ходов[Текущий_ход]}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))



# 6 - Бет
    '''
Бет (Bet): 
– сделать первую ставку (минимум равную большому блайнду).
Пример: /покер бет 200
Где: 200 – поставленная сумма фишек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате,
•	Игра ещё не началась, 
•	Сейчас не твой ход (указывает чей сейчас ход), 
•	Выбранная сумма не является целым числом ИЛИ числом вообще, ИЛИ не больше или равна большому блайнду (указывает в ответе минимально доступную ставку для бет),
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт),
•	Уже был сделан Бет (сделана первая ставка), рекомендует сделать Рейз для повышения ставки, называет для него минимально допустимую сумму фишек (в два раза большую текущей ставки)
•	Аргумент не введён,
•	
    '''
    @app_commands.command(name = "бет", description="сделать ставку")
    async def _бет(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Текущая_ставка: int = room.Текущая_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер'], Ставка = Ставка):
            return

# 7 - Рейз
    '''
Рейз (Raise): 
Повышение текущей ставки (больше текущей ставки как минимум в 2 раза).
Пример: /покер рейз 200
Где: 200 – поставленная сумма фишек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате,
•	Игра ещё не началась, 
•	Сейчас не твой ход (указывает чей сейчас ход), 
•	Выбранная сумма не является целым числом ИЛИ числом вообще, ИЛИ не больше или равна текущей ставки в 2 раза (указывает в ответе минимально доступную ставку рейза),
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт),
•	Аргумент не введён,
•	
    '''
    @app_commands.command(name = "рейз", description="повысить ставку")
    async def _рейз(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Текущая_ставка: int = room.Текущая_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер'], Ставка = Ставка):
            return
        

# 8 - Фолд
    '''
Фолд (Fold): 
Сброс карт и выход из текущей раздачи. Не выгоняет из комнаты, но убирает из списка ходов, подвигая всех участников. Все поставленные деньги переходят в банк.
Проверяет, сколько участников осталось, если один – уведомляет о его победе, вызывает функцию победителя.
Пример: /покер фолд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате,
•	Игра ещё не началась, 
•	Сейчас не твой ход (указывает чей сейчас ход), 
    '''
    @app_commands.command(name = "фолд", description="сбросить карты")
    async def _фолд(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Текущая_ставка: int = room.Текущая_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер'], Ставка = Ставка):
            return



# -------------     Вспомогательные команды:    -------------

# 9 - Рука
    '''
Рука:
Отображает:
•	карты, которые у тебя сейчас на руках; 
•	карты на столе для удобства просмотра комбинаций;
•	имя наилучшей комбинации и её состав; 
•	текущую ставку;
•	Банк этого раунда;
•	Общий банк;
•	Баланс твой текущий;
•	Сколько уже поставлено всего;
•	Какую сумму поставил в этом раунде;
•	Указывает, чей сейчас ход, какой у него номер;
•	Указывает твой номер хода;
Пример: /покер рука
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате,
•	Игра ещё не началась, 
•	
    '''
    @app_commands.command(name = "рука", description="посмотреть карты")
    async def _рука(self, interaction: Interaction):
        ID = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Текущая_ставка: int = room.Текущая_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if not await FuncP.check_error(interaction, user, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер'], Ставка = Ставка):
            return
        

# 10 - Статистика
    '''
Статистика:
Отображает статистику (свою или выбранного игрока). Желательно без пинга. Можно использовать вне игры.
Пример: /покер статистика @Джон
Возвращает ошибку, если:
•	Указано неверное айди или имя (по формату),
•	Указанного игрока нет в БД (среди всех серверов),
•	
    '''


async def setup(bot: commands.Bot) -> None:
    await bot.add_cog(Poker_Player(bot))