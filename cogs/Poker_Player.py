# Poker_Player.py

import discord
from discord.ext import commands
from discord import app_commands, Interaction
from discord import ui # Диалоговое окно
from discord.ui import  Button, View
from .models.MainModels import User
from .models.PokerModels import Room
from .configs import MainConfig as MC
from .configs import PokerConfig as PC
from .embeds.MainEmbed import Embed
from .functions.MainFunction import Func
from .functions.PokerFunction import FuncP
import random
from typing import List, Any

class Poker_Player(commands.GroupCog, name="покер"): # создаёт класс команд
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        super().__init__()


# 0 - начать
    '''
Покер начать:
Начинает игру: 
выводит список участников: кто ходит каким, +
называет минимальную сумму для малого блайнда, +
Карты ещё НЕ выдаёт! +
Также выводит общую информацию по текущей игре:
    вид покера, +
    тип ставок, +
    макс.ставку +
    и т.п.), *???
желает приятной игры. +
Пример: /покер начать
Возвращает ошибку, если:
•	Если ты не состоишь ни в одной комнате, +
•	Команду вводит не создатель комнаты (отображать создателя в командах с таким разрешением / уровнем доступа), +
•	Уже идёт игра, +
•	В комнате всего 1 человек, +
    '''
    @app_commands.command(name = "начать", description="начать игру") # balance
    async def _начало_игры(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
    # Проверяем ошибки
        Комната: str = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
        Создатель: int = room.Создатель
        if Создатель != ID:
            await Func.error(interaction, f'Вы не являетесь создателем комнаты "{Комната}".\nЕё создатель: <@{Создатель}>.')
            return
        Текущий_раунд: str = room.Текущий_раунд
        if Текущий_раунд != 'не начата':
            await Func.error(interaction, f'Игра уже началась - текущий раунд: "{Текущий_раунд}".\nДождитесь окончания игры.')
            return
        Участники: list = room.Участники # список с ID участников
        if len(Участники) < 2:
            await Func.error(interaction, f'Для начала игры требуется наличие как минимум двух участников.')
            return
    # Перемешиваем порядок ходов и заносим в БД
        random.shuffle(Участники)
        room.update_field('Порядок_ходов', Участники)
        порядок_ходов = await FuncP.move_order(interaction, Участники) # функция для красивого вывода порядка ходов
        # room.след_ход() # делаем +1 к следующему ходу (далее ходит первый)
        room.след_раунд('начало')
    # Выводим данные для отображения
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Мин_ставка: int = room.Мин_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка) # Выводит сообщение о максимальной ставке в зависимости от типа ставок
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Вы можете начинать играть',
f"Порядок ходов:\n{порядок_ходов}\n\n\
Тип ставок: {Тип_ставок}\n\
Малый блайнд: {Мин_ставка//2}\n\
Минимальная ставка (большой блайнд): {Мин_ставка}\n\
{text}\n\
\nПриятной игры!"))


# 1 - отмена
    '''
Покер отмена:
Отменяет игру, если не сделано ещё ни одного хода. Команда нужна на тот случай, если про какого-то игрока забыли или он не успел войти, и это как раз могли заметить в списке игроков при вводе команды: /покер начать. Также, например, если кто-то передумал играть.
Пример: /покер отмена
Возвращает ошибку, если:
•	Если ты не состоишь ни в одной комнате,
•	Команду вводит не создатель комнаты??? (отображать создателя в командах с таким разрешением / уровнем доступа), 
•	Игра ещё не началась,
•	Сделано 1 и более ходов.

! можно просто ввести второй раз команду: /покер начать
    '''

# 2 - малый_блайнд
    '''
Покер малый_блайнд:
Команда для первого хода в игре. Минимальная ставка, чтобы наполнить банк. 
Отображает:
    сделанную ставку малого блайнда (она же текущий банк), 
    минимальную сумму для большого блайнда, 
    говорит, кто ставит большой блайнд (ходит вторым). 
    Выводит список участников: кто ходит каким.
Операции с БД:
у игрока отнимает монеты
В банк игры добавляет монеты,
Обновляет текущую ставку,
переключает на следующий ход (большой блайнд ещё и на следующий раунд)
Пример: /покер малый_блайнд 50,
Где: 50 – сумма, обозначающая минимальный блайнд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась / уже началась, +
•	Сейчас не первый ход (указывает чей сейчас ход), +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Указанная сумма не является целым числом ИЛИ числом вообще, ИЛИ более чем в два раза меньше заданной изначально администратором суммы большого блайнда (Пусть будет фиксированной), +
•	Недостаточно монет, +
    '''
    @app_commands.command(name = "малый_блайнд", description="сделать первый ход")
    async def _малый_блайнд(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Мин_ставка: int = room.Мин_ставка
        Ставка: int = round(Мин_ставка//2) # = большой блайнд / 2 = малый блайнд
        if not await FuncP.check_error_blind(interaction = interaction, room = room, Ставка = Ставка, Ход = 0):
            return
        # interaction: Interaction, user: User, room: Optional[Room], Cтавка: int
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Текущий_ход: int = room.Текущий_ход
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
    # Операции с БД: вычитаем из баланса, добавляем денег в банк, переходим к следующему ходу
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.след_ход()             # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.новая_ставка(Ставка)   # изменяем Текущую ставку ('Текущая_ставка')
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ставка сделана!',
f"<@{ID}> сделал ставку (Малый блайнд): {Ставка}\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {room.Текущая_ставка}\n\
Минимальная ставка: {Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк: {room.Банк_раунда}\n\
\Следующим ходит: <@{room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]}>"))
        

# 3 - большой_блайнд
    '''
Покер большой_блайнд:
Команда для второго хода в игре. Ещё одна ставка, чтобы наполнить банк. 
Отображает сделанную ставку большого блайнда, +
суммирует с малым – показывает банк, +
Раздаёт по две карты игрокам, +
Урезаем колоду карт, +
Обновляет текущую ставку, +
уведомляет о том, что они могут использовать команду /покер рука – для просмотра карт в руке. +
Говорит, кто ходит третьим. +
Меняет название «начало игры» на раунд «Пре-флоп (Pre-Flop)». +
В БД делает запись о том, что началась по сути игра, раунд Пре-флоп, +
Пример: /покер большой_блайнд 50,
Где: 50 – сумма, обозначающая минимальный блайнд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не второй ход (указывает чей сейчас ход), +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Указанная сумма не является целым числом ИЛИ числом вообще, ИЛИ не больше или равна малому блайнду (заданного на первом ходе) умноженного на два (Пусть будет фиксированной), +
•	Недостаточно монет, +
    '''
    @app_commands.command(name = "большой_блайнд", description="сделать второй ход")
    async def _большой_блайнд(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        Ставка: int = room.Мин_ставка # = большому блайнду
        if not await FuncP.check_error_blind(interaction, room = room, Ставка = Ставка, Ход = 1):
            return
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Текущий_ход: int = room.Текущий_ход
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
    # Операции с БД: вычитаем из баланса, добавляем денег в банк, переходим к следующему ходу
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.след_ход()             # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.новая_ставка(Ставка)   # изменяем Текущую ставку ('Текущая_ставка')
        room.след_раунд('пре-флоп') # ставки игроков при этом не обнуляем (именно на первом кругу), просто меняем название раунда
    # Раздаём по 2 карты игрокам
        Колода: list[list] = PC.Колода
        random.shuffle(Колода) # Перемешиваем колоду
        Порядок_ходов: list[int] = room.Порядок_ходов
        for idP in Порядок_ходов: # Цикл раздачи карт
            player = User(idP)  # Получаем объект игрока
            a1:list[Any] = Колода.pop()
            room.обновляем_колоду(Колода) # фиксируем колоду в БД комнаты
            Колода: list[list] = room.Колода
            a2:list[Any] = Колода.pop()
            карты: list[list] = [a1, a2]  # Убираем две карты из колоды и даём их игроку
            '''
            Если третий элемент первого подсписка меньше второго, меняем их местами (сравниваем вес/силу карт)
            Так всегда сначала будет идти самая весомая/сильная/старшая карта
            '''
        # сразу сортируем: первая карта в руках будет более сильной
            if карты[0][2] < карты[1][2]:   
                карты[0], карты[1] = карты[1], карты[0]
            player.установить('Карты', карты) # Сохраняем карты игрока у него в БД
            print(f"Игрок {idP} получил карты: {карты}") # Для отладки, можно вывести, кому какие карты разданы
        room.обновляем_колоду(Колода) # фиксируем колоду в БД комнаты
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ставка сделана!',
f"<@{ID}> сделал ставку (Большой блайнд): {Ставка}\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {room.Текущая_ставка}\n\
Минимальная ставка: {Ставка}\n\
Максимальная ставка: {text}\n\
Банк: {room.Банк_раунда}\n\
\nРаунд обновлён: начало -> пре-флоп\n\
Следующим ходит: <@{room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]}>\n\
\nПодсказка:\n\
Вам раздали карты! Используйте команду /покер рука – для просмотра карт в руке."))






    '''
Команды для самой игры:
*Каждая такая команда: 
•	выводит действие текущего игрока,  
•	тип ставок,
•	текущую ставку (как минимальную),
•	максимальную ставку (если есть),
•	обновляет список (очерёдность хода), 
•	отображает текущий раунд, 
•	сумму монет/фишек в банке (всего и в текущем раунде),
•	показывает карты на столе. 
если нужно:
•	уведомляет о смене раунда, 
•	обнуляет банк этого раунда, 
•	добавляет карты на стол 
•	В конце игры – вызывает меню победителей.
Выдаёт ошибку, если:
•	Игра ещё не началась, (ТОЛЬКО fold - позволяет ливнуть тем, кто делает малый и большой блайнд в первые пару ходов (пока игра со статусом "началась"))
•	Ты не состоишь ни в одной комнате,
•	Сейчас не твой ход,

У некоторых:
СТАВКА не может быть больше максимальной (считать в зависимости от типа ставок - отдельную функцию для этого сделать)
    '''

# 4 - Чек
    '''
Чек (Check):
Если никто не делал ставок, игрок может пропустить ход, не вкладывая деньги в банк. (т.е. если поставленная сумма до тебя равна твоей ставке)
На префлопе сделать чек может только большой блайнд, и то если до этого не повышали ставку.
Пример: /покер чек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Ещё раунд пре-флоп, а ты не большой блайнд (не ходишь вторым), + 
•	Ставку до тебя повысили, +
    '''
    @app_commands.command(name = "чек", description="пропустить ход")
    async def _чек(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер']):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # Проверка остальных ошибок:
        Текущий_раунд: str = room.Текущий_раунд
        Порядок_ходов: list[int] = room.Порядок_ходов
        if (Текущий_раунд == 'пре-флоп') and (ID != Порядок_ходов[1]):
            await Func.error(interaction, f'На префлопе сделать чек может только большой блайнд (второй игрок): <@{Порядок_ходов[1]}>')
            return False
        Текущая_ставка = room.Текущая_ставка
        Сейчас_поставил = user.Сейчас_поставил
        if  (Сейчас_поставил != Текущая_ставка):
            await Func.error(interaction, f'До твоего хода ставку повысили.\nТекущая ставка: {Текущая_ставка}.\nТы уже поставил: {Сейчас_поставил}.\nНе хватает: {Текущая_ставка-Сейчас_поставил}\nИспользуй "/покер колл", чтобы уровнять ставку.')
            return False
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        обновление_раунда: str = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: переходим к следующему ходу и, при необходимости, к следующему раунду
        Текущий_ход: int = room.Текущий_ход
        room.след_ход()     # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
    # Если прошёл уже один круг и у всех ставки равны - начинаем следующий раунд
        след_ход: str = room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]
        if room.Круг and room.ставки_равны(): 
            обновление_раунда: str = await FuncP.обновить_раунд(interaction, room)
            if not interaction.response.is_done(): # если игра закончена, то след_ход считаем с нуля
                след_ход: str = room.Порядок_ходов[0]
            else: pass
        else: pass # идём дальше
    # Отправляем сообщение, ТОЛЬКО если игра НЕ ЗАКОНЧЕНА:
        if not interaction.response.is_done(): # если игра закончена, то сообщение отправится в функции победителей
        # Данные для вывода текста
            Тип_ставок: str = room.Тип_ставок
            Макс_ставка: int = room.Макс_ставка
            text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
            Карты_стола: list = room.Карты_стола
            print('Карты_стола: ', Карты_стола)
            карты_вывод: str = ''
            if Карты_стола:
                карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
            else: pass
        # Выводим сообщение
            await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{ID}> использовал /покер чек (пропустил ход)\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {Текущая_ставка}\n\
Минимальная ставка: {room.Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следующим ходит: <@{след_ход}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))

        '''
Команды для самой игры:
*Каждая такая команда: 
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (как минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, + 
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока + - room.сбросить_ставки() +
•	В конце игры – вызывает меню победителей. 
        '''

# 5 - Колл
    '''
Колл (Call):  
Уравнивание ставки
На пре-флопе: если сделали ставку, т.е. если текущая ставка не равна 0. (а она и так не равна 0 из-за большого блайнда)
На всех остальных кругах: если текущая ставка не равна 0.
Обновляем банк. +
Пример: /покер колл
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт), +
•	Ставку до тебя не повышали (рекомендует использовать Чек для пропуска хода или Бет для поднятия ставки), +
    '''
    @app_commands.command(name = "колл", description="уравнять ставку")
    async def _колл(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер']):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # Проверка остальных ошибок:
        Текущая_ставка: int = room.Текущая_ставка
        if Текущая_ставка == 0:
            await Func.error(interaction, f'В этом раунде ставку ещё не делали.\nМожешь использовать "/покер чек" для пропуска хода или "/покер бет" для новой ставки')
            return False
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Текущая_ставка - Сейчас_поставил
        if Ставка == 0: 
            '''
        Это условие обязательно, хоть и выполнимо лишь в одном случае. Для него тебе надо, чтобы: 
        До тебя дошёл ход и твоя ставка совпадает с текущей, то есть ставки уравнены и не нулевые (проверяется выше), 
        Следовательно, ты уже ставил, и как правило, должен бы начинаться следующий круг, но:
        Это возможно на пре-флопе, если играют 2 игрока, и малый блайнд (первый на пре-флопе) сделал /колл или /бет со ставкой, равной большому блайнду. 
        Следовательно, ты - большой блайнд (ходишь вторым на пре-флопе), и все ставки в игре равны, но круг не заканчивается, т.к. ещё есть твой ход.
        Прожимать /колл - бессмысленно, поэтому:
            '''
            await Func.error(interaction, f'До твоего хода ставку не повышали.\nМожешь использовать "/покер чек" для пропуска хода или "/покер рейз" для поднятия ставки')
            return False
        Баланс: int = user.Баланс
        if Баланс < Ставка: # Не хватает фишек
            await Func.error(interaction, f'Недостаточно средств.\nУ тебя: {Баланс}\nТребуется: {Ставка}.\nМожешь использовать "/покер фолд", чтобы выйти из игры.')
            return False
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        Текущий_раунд: str = room.Текущий_раунд
        обновление_раунда = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: делаем ставку, обновляем банк, переходим к следующему ходу и, при необходимости, к следующему раунду
        Текущий_ход: int = room.Текущий_ход
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.след_ход()     # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
    # Если прошёл уже один круг и у всех ставки равны - начинаем следующий раунд
        след_ход: str = room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]
        if room.Круг and room.ставки_равны(): 
            обновление_раунда: str = await FuncP.обновить_раунд(interaction, room)
            if not interaction.response.is_done(): # если игра закончена, то след_ход считаем с нуля
                след_ход: str = room.Порядок_ходов[0]
            else: pass
        else: pass # идём дальше
    # Отправляем сообщение, ТОЛЬКО если игра НЕ ЗАКОНЧЕНА:
        if not interaction.response.is_done(): # если игра закончена, то сообщение отправится в функции победителей
        # Данные для вывода текста
            Тип_ставок: str = room.Тип_ставок
            Макс_ставка: int = room.Макс_ставка
            text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
            Карты_стола = room.Карты_стола
            карты_вывод: str = ''
            if Карты_стола:
                карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
            else: pass
        # Выводим сообщение
            await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{ID}> использовал /покер колл (уравнял ставку на {Ставка})\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {Текущая_ставка}\n\
Минимальная ставка: {room.Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следующим ходит: <@{след_ход}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))

        '''
Команды для самой игры:
*Каждая такая команда:
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (и минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, +
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока  - room.сбросить_ставки() +
•	В конце игры – вызывает меню победителей. 
        '''

# 6 - Бет
    '''
Бет (Bet): 
– сделать первую ставку (минимум равную большому блайнду).
На префлопе невозможен, т.к. надо рейз делать или колл для того чтоб перебить / уровнять большой блайнд.
С флопа: бет делается если текущая ставка = 0 
Пример: /покер бет 200
Где: 200 – поставленная сумма фишек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Указанная ставка меньше большого блайнда (указывает в ответе минимально доступную ставку для бет), +
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт), +
•	Уже был сделан Бет (сделана первая ставка), рекомендует сделать Рейз для повышения ставки, называет для него минимально допустимую сумму фишек (в два раза большую текущей ставки) +
•	Аргумент не введён, +
•	больше максимальной (считать в зависимости от типа ставок - отдельную функцию для этого сделать) +
    '''
    @app_commands.command(name = "бет", description="сделать ставку")
    @app_commands.rename(Новая_ставка='ставка') # переименовывает атрибут в интерфейсе дискорда для пользователей
    async def _бет(self, interaction: Interaction, Новая_ставка: int):
        ID: int = interaction.user.id
        user = User(interaction.user.id)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, room = room, Раунд = ['флоп', 'тёрн', 'ривер']): # УБРАЛ Пре-флоп, хоть это и не обязательно
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # Проверка - делали ли ставку:
        Текущая_ставка: int = room.Текущая_ставка
        if Текущая_ставка != 0:
            await Func.error(interaction, f'В этом раунде ставку уже делали.\nМожешь использовать "/покер колл" для уравнения ставки или "/покер рейз <{Текущая_ставка*2}+>" для увеличения ставки') 
            return False
    # Проверка остальных ошибок:
        Мин_ставка: int = room.Мин_ставка
        Макс_ставка = room.Макс_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Новая_ставка - Сейчас_поставил
        Баланс: int = user.Баланс
        if not await FuncP.check_error_bet(interaction, Новая_ставка, Мин_ставка, Макс_ставка, Баланс, Ставка):
            return  # Cтавка меньше большого блайнда, Больше максимальной, Не хватает фишек
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        Текущий_раунд: str = room.Текущий_раунд
        обновление_раунда = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: делаем ставку, обновляем банк, переходим к следующему ходу и, при необходимости, к следующему раунду
        Текущий_ход: int = room.Текущий_ход
        user.ставка(Ставка)             # Баланс проверяется в проверке ошибок FuncP.check_error_bet (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.обновляем_банк(Ставка)     # увеличиваем Банк_раунда и Банк_общий
        room.след_ход()                 # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        room.новая_ставка(Новая_ставка) # изменяем Текущую ставку ('Текущая_ставка')
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
        Карты_стола = room.Карты_стола
        карты_вывод: str = ''
        if Карты_стола:
            карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
        else: pass
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{ID}> использовал /покер бет (Поднял свою ставку с {Сейчас_поставил} до {Новая_ставка})\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {room.Текущая_ставка}\n\
Минимальная ставка: {room.Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следующим ходит: <@{room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))

        '''
Команды для самой игры:
*Каждая такая команда:
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (как минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, +
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока - room.сбросить_ставки() +
•	В конце игры – вызывает меню победителей. 
        '''


# 7 - Рейз
    '''
Рейз (Raise): 
Повышение текущей ставки (больше текущей ставки как минимум в 2 раза).
Пример: /покер рейз 200
Где: 200 – поставленная сумма фишек
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
•	Выбранная сумма не больше или равна текущей ставки в 2 раза (указывает в ответе минимально доступную ставку рейза), +
•	Не хватает фишек (показывает текущий баланс, и сумму, которой не достаёт), +
•	Аргумент не введён, +
•	больше максимальной (считать в зависимости от типа ставок - отдельную функцию для этого сделать) +
    '''
    @app_commands.command(name = "рейз", description="повысить ставку")
    @app_commands.rename(Новая_ставка='ставка') # переименовывает атрибут в интерфейсе дискорда для пользователей
    async def _рейз(self, interaction: Interaction, Новая_ставка: int):
        ID: int = interaction.user.id
        user = User(interaction.user.id)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер']):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # Проверка - делали ли ставку:
        Текущая_ставка: int = room.Текущая_ставка
        if Текущая_ставка == 0:
            await Func.error(interaction, f'В этом раунде ставку ещё не делали.\nМожешь использовать "/покер чек" для пропуска хода или "/покер бет <{room.Мин_ставка}+>" для новой ставки') 
            return False
    # Проверка остальных ошибок:
        Мин_ставка: int = room.Текущая_ставка * 2
        Макс_ставка = room.Макс_ставка
        Сейчас_поставил: int = user.Сейчас_поставил
        Ставка: int = Новая_ставка - Сейчас_поставил
        Баланс: int = user.Баланс
        if not await FuncP.check_error_bet(interaction, Новая_ставка, Мин_ставка, Макс_ставка, Баланс, Ставка):
            return  # Ставка меньше текущей, умноженной на 2; Больше максимальной; Не хватает фишек        
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        Текущий_раунд: str = room.Текущий_раунд
        обновление_раунда = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: делаем ставку, обновляем банк, переходим к следующему ходу и, при необходимости, к следующему раунду
        Текущий_ход: int = room.Текущий_ход
        user.ставка(Ставка)         # Баланс проверяется в проверке ошибок FuncP.check_error_bet (выше). Здесь мы уменьшаем 'Баланс' и увеличиваем поля 'Сейчас_поставил', 'Всего_поставил' и 'Общая_ставка' в БД игрока на эту сумму
        room.обновляем_банк(Ставка) # увеличиваем Банк_раунда и Банк_общий
        room.след_ход()             # прибавляем к полю 'Текущий_ход' +1 (сбрасываем до нуля при достижении максимума)
        room.новая_ставка(Новая_ставка)   # изменяем Текущую ставку ('Текущая_ставка')
    # Данные для вывода текста
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
        Карты_стола = room.Карты_стола
        карты_вывод: str = ''
        if Карты_стола:
            карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
        else: pass
    # Выводим сообщение
        await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{ID}> использовал /покер рейз (поднял свою ставку с {Сейчас_поставил} до {Новая_ставка})\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {room.Текущая_ставка}\n\
Минимальная ставка: {room.Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следующим ходит: <@{room.Порядок_ходов[(Текущий_ход + 1) % len(room.Порядок_ходов)]}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))
    
        '''
Команды для самой игры:
*Каждая такая команда:
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (как минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, +
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока  - room.сбросить_ставки() +
•	В конце игры – вызывает меню победителей. 
        '''



# 8 - Фолд
    '''
Фолд (Fold): 
Сброс карт и выход из текущей раздачи. 
Не выгоняет из комнаты, но убирает из списка ходов, подвигая всех участников. +
Убирает карты, обнуляет поставленные суммы, увеличивает кол-во игр (также оно увеличивается при функции победителя у всех остальных) +
Проверяет, сколько участников осталось, если один – уведомляет о его победе, награждает без вызова функции победителя +
Пример: /покер фолд
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	Сейчас не твой ход (указывает чей сейчас ход), +
    '''
    @app_commands.command(name = "фолд", description="сбросить карты")
    async def _фолд(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(interaction.user.id)
        Комната = user.Комната
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
    # Проверка всех ошибок сразу
        if not await FuncP.check_error(interaction, room = room, Раунд = ['пре-флоп', 'флоп', 'тёрн', 'ривер']):
            return # Ты не состоишь ни в одной комнате, Игра ещё не началась, Сейчас не твой ход
    # текст (важно, чтоб стоял до другого текста в случае обновления раунда)
        Текущий_раунд: str = room.Текущий_раунд
        обновление_раунда = f'Текущий раунд: {Текущий_раунд}\n' # текст меняется если раунд обновился
    # Операции с БД: делаем ставку, обновляем банк, переходим к следующему ходу и, при необходимости, к следующему раунду
        Текущий_ход: int = room.Текущий_ход
        Всего_поставил = user.Всего_поставил # сколько было поставлено в игре
        user.сброс_ставки()         # Здесь мы обнуляем поля 'Сейчас_поставил', 'Всего_поставил' в БД игрока, а также 'Карты': None, 'Кол-во_игр': +1
        room.след_ход_фолд()        # устанавливаем 'Текущий_ход' = 0, если этот человек был последним в кругу. Не прибавляем +1, т.к. вместо него будет ходить следующий по списку, которого он подвинул вперёд своим выходом
        room.отстранить_игрока(ID)  # Удаляет указанный ID из списка 'Порядок_ходов'
        '''
        Следующий_ход : int = room.Текущий_ход
        if Следующий_ход == 1: # если номер этого хода был вторым (ходил большой блайнд), то обновляем раунд
            обновление_раунда: str = await FuncP.обновить_раунд(interaction, room)
        else: pass # идём дальше
        '''
    # Если прошёл уже один круг и у всех ставки равны - начинаем следующий раунд
        след_ход: str = room.Порядок_ходов[(Текущий_ход) % len(room.Порядок_ходов)]
        if room.Круг and room.ставки_равны(): 
            обновление_раунда: str = await FuncP.обновить_раунд(interaction, room)
            след_ход: str = room.Порядок_ходов[0]
        else: pass # идём дальше
    # Отправляем сообщение, ТОЛЬКО если игра НЕ ЗАКОНЧЕНА:
        if not interaction.response.is_done(): # если игра закончена, то сообщение отправится в функции победителей
        # Если остался один человек, а игра не закончилась т.к. раунд последний не достигнут, то заканчиваем:
            Участники: list[int] = room.Порядок_ходов
            if len(Участники) == 1: 
            # Конец игры
                '''
                Вместо вызыва функции победителей (т.к. победитель и так ясен) делаем все вычисления внутри кода:
                Награждаем победителя, сбрасываем все данные кроме статистики
                '''
                IDwin: int = Участники[0]   # определяем ID победителя
                Winner = User(IDwin)
                Выигрыш: int = room.Банк_общий
                Проигрыш = Winner.Всего_поставил
            # Изменяем БД последнего игрока (у остальных БД сбросилась при выходе)
                Winner.наградить(Выигрыш)   # Зачисляем выигрыш, увеличиваем статистику 'Общий_выигрыш': +Выигрыш, 'Кол-во_побед': +1
                Winner.сброс_ставки()       # Здесь мы обнуляем поля 'Сейчас_поставил', 'Всего_поставил' в БД игрока, а также 'Карты': None, 'Кол-во_игр': +1
            # Сбрасываем БД комнаты
                room.сброс_комнаты()
                await interaction.response.send_message(embed=Embed.комната('Игра окончена! (остался 1 игрок)', 
f'<@{ID}> использовал /покер фолд (вышел из игры, оставив в банке {Всего_поставил})\n\n\
Побеждает <@{IDwin}>, и забирает банк ({Выигрыш}) себе\n\
(Прибыль: {Выигрыш-Проигрыш})\n\
\nПодсказка:\n\
Для начала новой игры создатель комнаты должен ввести: "/покер начать"'))
            else: 
            # Данные для вывода текста
                Тип_ставок: str = room.Тип_ставок
                Макс_ставка: int = room.Макс_ставка
                text: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
                Карты_стола = room.Карты_стола
                карты_вывод: str = ''
                if Карты_стола:
                    карты_вывод = " ".join(карта[0] for карта in Карты_стола) + '\n\n'
                else: pass
            # Выводим сообщение
                await interaction.response.send_message(embed = Embed.комната('Ход сделан!',
f"<@{ID}> использовал /покер фолд (вышел из игры, оставив в банке {Всего_поставил})\n\n\
Тип ставок - {Тип_ставок}\n\
Текущая ставка: {room.Текущая_ставка}\n\
Минимальная ставка: {room.Мин_ставка}\n\
Максимальная ставка: {text}\n\
Банк раунда: {room.Банк_раунда}\n\
Банк общий: {room.Банк_общий}\n\
\n{карты_вывод}{обновление_раунда}Следующим ходит: <@{след_ход}>\n\
\nПодсказка:\n\
Используйте команду /покер рука – для просмотра карт в руке."))
        '''
Команды для самой игры:
*Каждая такая команда:
•	выводит действие текущего игрока, +
•	тип ставок, +
•	текущую ставку (как минимальную), +
•	максимальную ставку (если есть), +
•	обновляет список (очерёдность хода), +
•	отображает текущий раунд, +
•	сумму монет/фишек в банке (всего и в текущем раунде), +
•	показывает карты на столе. +
если нужно:
•	уведомляет о смене раунда, +
•	обнуляет банк этого раунда, +
•	добавляет карты на стол +
•	сбрасывает поле "Сейчас_поставил" для каждого игрока  - room.сбросить_ставки() +
•	В конце игры – вызывает меню победителей. 
        '''



# -------------     Вспомогательные команды:    -------------

# 9 - Рука
    '''
Рука:
Отображает:
•	карты, которые у тебя сейчас на руках; 
•	карты на столе для удобства просмотра комбинаций;
•	имя наилучшей комбинации и её состав; 
•	текущую ставку;
•	Банк этого раунда;
•	Общий банк;
•	Баланс твой текущий;
•	Сколько уже поставлено всего;
•	Какую сумму поставил в этом раунде;
•	Указывает, чей сейчас ход, какой у него номер;
•	Указывает твой номер хода;
Пример: /покер рука
Возвращает ошибку, если:
•	Ты не состоишь ни в одной комнате, +
•	Игра ещё не началась, +
•	
    '''
    @app_commands.command(name = "рука", description="посмотреть карты")
    async def _рука(self, interaction: Interaction):
        ID: int = interaction.user.id
        user = User(ID)
        Комната = user.Комната
    # Проверка ошибок
        if not Комната:
            await Func.error(interaction, f'Вы не находитесь ни в одной комнате.')
            return
        room = Room(Комната)
        Текущий_раунд = room.Текущий_раунд
        if Текущий_раунд == 'не начата':
            await Func.error(interaction, f'Игра ещё не началась.')
            return False
    # Информация о картах
        Рука: list[list] = user.Карты
        if Рука:
            Карты_руки: str = " ".join(Карта[0] for Карта in Рука)
            Карты_руки_текст: str = f'**Ваши карты:** {Карты_руки}\n\n'
        else:
            Карты_руки_текст: str = f'**Ваши карты:** ещё не розданы\n\n'
        Стол: list[list] = room.Карты_стола
        if Стол and Рука: # при фолде может быть такое, что стол есть, а руки нет
            Карты_стола: str = " ".join(Карта[0] for Карта in Стол)
            Карты_стола_текст: str = f'**Карты стола:** {Карты_стола}\n\n'
            Комбинация: List[List[Any]]
            Сила_комбинации: int
            Комбинация, Сила_комбинации = FuncP.лучшая_комбинация(Рука, Стол) # Получаем лучшую комбинацию игрока
            Название_комбинации: str = PC.названия_комбинаций[Сила_комбинации]
            print('Комбинация:', Комбинация)
            print('Название_комбинации:', Название_комбинации)
            Карты_комбинации: str = " ".join(Карта[0] for Карта in Комбинация)
            Комбинация_текст: str = f'\
**Лучшая комбинация:** {Название_комбинации}\n\n\
**Карты комбинации:** {Карты_комбинации}\n\n'
        else:
            Карты_стола_текст: str = '**Карты стола:** ещё не розданы\n\n'
            Комбинация_текст: str = ''
    # Информация о фишках
        Тип_ставок: str = room.Тип_ставок
        Макс_ставка: int = room.Макс_ставка
        Макс_ставка_текст: str = FuncP.max_bet(Тип_ставок, Макс_ставка)
    # Информация о ходах
        Текущий_ход: int = room.Текущий_ход
        Порядок_ходов: list[int] = room.Порядок_ходов
        тек_ход: str = Порядок_ходов[Текущий_ход]
        след_ход: str = Порядок_ходов[(Текущий_ход+1) % len(Порядок_ходов)]
        # определяем, ходит ли человек (он мог зайти после начала игры или выйти чз /покер фолд):
        if ID in Порядок_ходов: 
            индекс = Порядок_ходов.index(ID)
            Номер_хода_текст: str = f'**Ваш номер хода:** {индекс+1}\n\n'
        else:
            Номер_хода_текст: str = '**Ваш номер хода:** Вы не участвуете в текущей игре\n\n'
        текст = f'\
\
**__<@{ID}>__:**\n\n\
{Карты_руки_текст}\
{Карты_стола_текст}\
{Комбинация_текст}\
\n\
**Тип ставок:** {Тип_ставок}\n\n\
**Текущая ставка:** {room.Текущая_ставка}\n\n\
**Ваша ставка:** {user.Сейчас_поставил}\n\n\
**Минимальная ставка:** {room.Мин_ставка}\n\n\
**Максимальная ставка:** {Макс_ставка_текст}\n\n\
**Банк раунда:** {room.Банк_раунда}\n\n\
**Банк общий:** {room.Банк_общий}\n\n\
\n\
**Текущий раунд:** {Текущий_раунд}\n\n\
{Номер_хода_текст}\
**Всего участников:** {len(Порядок_ходов)}\n\n\
**Текущий ход:** <@{тек_ход}> ({Текущий_ход + 1})\n\n\
**Следующим ходит:** <@{след_ход}> ({(Текущий_ход + 1) % len(Порядок_ходов) + 1})\n\n\
'
        await interaction.response.send_message(embed = Embed.комната('Это сообщение видите только Вы',текст), ephemeral = True)

# 10 - Статистика
    '''
Статистика:
Отображает статистику (свою или выбранного игрока, или всех человек в комнате). Желательно без пинга. Можно использовать вне игры.
Пример: /покер статистика @Джон
Возвращает ошибку, если:
•	Указано неверное айди или имя (по формату),
•	Указанного игрока нет в БД (среди всех серверов),
•	
    '''


async def setup(bot: commands.Bot) -> None:
    await bot.add_cog(Poker_Player(bot))