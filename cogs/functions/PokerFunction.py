# PokerFunction.py

# import discord
from discord.ext import commands
from discord import Interaction
from ..embeds.MainEmbed import Embed
from .MainFunction import Func
from ..models.MainModels import User
from ..models.PokerModels import Room
from ..configs import PokerConfig as PC
from typing import Optional, Dict, List, Any, Tuple
import random
from collections import defaultdict     # для комбинаций в покере

class FuncP(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

# Функция для вывода текста (о макс-ой ставке) в зависимости от типа ставок
    def max_bet(type: str, bet: int = None) -> str: # так как нет обращения к API / БД, можно сделать ф-цию не асинхронной (синхронной), это сделает код лучше (быстрее)
        match type: # Вывод будет в виде: 'Максимальная ставка: {return}'
            case "Fixed-Limit":
                return f"фиксирована: {bet}" if bet else "фиксирована"
            case "Pot-Limit":
                return "равна размеру текущего банка" 
            case "No-Limit":
                return "отсутствует"
            case "Spread-Limit":
                return f"до {bet}" if bet else "варьируется"
            case _:
                return "Неверный тип ставки"

# Выводит текст о порядке ходов, подчёркивая того, кто должен ходить далее
    async def move_order(interaction: Interaction, Участники: list) -> str:
        guild = interaction.guild
        ход_участников: list = []
        star: str = ''
        for index, user_id in enumerate(Участники, start=1):
            member = await guild.fetch_member(user_id)
            nickname = member.nick if member.nick else member.name # Получаем никнеймы участников
            if index == 1:
                star = '__'
            ход_участников.append(f"{star}{index}. {nickname}{star}")
            star: str = ''
        порядок_ходов = "\n".join(ход_участников) # Формируем итоговый текст о порядке ходов
        return порядок_ходов
    

# ФУНКЦИИ ОШИБОК
# Функция ошибок для малого и большого блайндов
    async def check_error_blind(interaction: Interaction, room: Optional[Room], Ставка: int, Ход: int) -> bool:
        user = User(interaction.user.id)
        Текущий_раунд = room.Текущий_раунд
        if Текущий_раунд == 'не начата':
            await Func.error(interaction, f'Игра ещё не началась.')
            return False
        if Текущий_раунд != 'начало':
            await Func.error(interaction, f'Большой и малый блайнды уже поставлены. Текущий раунд: "{Текущий_раунд}".')
            return False
        Текущий_ход = room.Текущий_ход
        if Текущий_ход != Ход:
            await Func.error(interaction, f'Сейчас нельзя вводить эту команду. Номер хода: {Текущий_ход+1}, а не {Ход}')
            return False
        ID_первого_игрока = room.Порядок_ходов[Текущий_ход]
        if interaction.user.id != ID_первого_игрока:
            await Func.error(interaction, f'Сейчас ход другого игрока: "<@{ID_первого_игрока}>".')
            return False
        Баланс = user.Баланс
        if Баланс < Ставка: # Не хватает фишек
            await Func.error(interaction, f'Недостаточно средств.\nУ вас: {Баланс}\nТребуется: {Ставка}')
            return False
        return True
    
# Функция ошибок для Бет и Рейз
    async def check_error_bet(interaction, Новая_ставка: int, Мин_ставка: int, Макс_ставка: int, Баланс: int, Ставка: int) -> bool:
        """
        Проверяет корректность новой ставки и отправляет сообщение об ошибке, если проверка не пройдена.
        interaction: объект взаимодействия Discord.
        Новая_ставка: новая ставка игрока.
        Мин_ставка: минимальная допустимая ставка.
        Макс_ставка: максимальная допустимая ставка.
        Баланс: текущий баланс игрока.
        Ставка: разница между новой ставкой и уже сделанной ставкой.
        :return: True, если проверка успешна, иначе False.
        """
        if Новая_ставка < Мин_ставка: # Указанная ставка меньше большого блайнда (бет) / меньше текущей, умноженной на 2 (рейз)
            await Func.error(interaction, f'Указанная ставка меньше минимальной.\nНужно поставить {Мин_ставка} или больше.')
            return False
        if Новая_ставка > Макс_ставка: # Указанная ставка больше максимальной
            await Func.error(interaction, f'Указанная ставка больше максимальной.\nНужно поставить {Макс_ставка} или меньше.')
            return False
        if Ставка < 0: # на всякий случай
            await Func.error(interaction, f'Ошибка! Ставка меньше нуля ({Ставка})')
            return False
        if Баланс < Ставка: # Не хватает фишек
            await Func.error(interaction, f'Недостаточно средств.\nУ вас: {Баланс}\nТребуется: {Ставка}')
            return False
        return True

# Функция ошибок для ставок
    async def check_error(interaction: Interaction, room: Optional[Room], Раунд: list) -> bool:
        """
        Проверяет основные ошибки.
        interaction: объект взаимодействия Discord.
        room:
        Раунд: Список раундов. Все раунды: ['не начата', 'начало', 'пре-флоп', 'флоп', 'тёрн', 'ривер']
        :return: True, если проверка успешна, иначе False.
        """
        Текущий_раунд = room.Текущий_раунд
        if Текущий_раунд == 'не начата':
            await Func.error(interaction, f'Игра ещё не началась.')
            return False
        if not (Текущий_раунд in Раунд):
            await Func.error(interaction, f'В этом раунде нельзя использовать эту команду. Текущий раунд: "{Текущий_раунд}".')
            return False
        Текущий_ход = room.Текущий_ход
        ID_первого_игрока = room.Порядок_ходов[Текущий_ход]
        if interaction.user.id != ID_первого_игрока:
            await Func.error(interaction, f'Сейчас ход другого игрока: "<@{ID_первого_игрока}>".')
            return False
        return True


# Функция ОБНОВЛЕНИЯ РАУНДА
    @classmethod
    async def обновить_раунд(cls, interaction: Interaction, room: Optional[Room]):
        Раунды: list[str] = PC.Раунды
        Текущий_раунд = room.Текущий_раунд
        if Текущий_раунд in Раунды:  # проверяем, есть ли название текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
            индекс = Раунды.index(Текущий_раунд) # индекс = номеру текущего раунда в списке 'Раунды' = ['не начата',..,'ривер']
            if индекс < len(Раунды) - 1: # Проверяем, есть ли следующий раунд или уже конец игры
                Следующий_раунд: str = Раунды[индекс + 1]
                room.след_раунд(Следующий_раунд)    # меняем название раунда на слеующее
                room.обнуляем_банк()                # 'Банк_раунда' = 0
                room.сбросить_ставки()              # для каждого игрока обнуляем поле 'Сейчас_поставил' (в этом раунде)
                room.новая_ставка(0)                # сбрасываем 'Текущая_ставка' для следующего раунда
                print('обновление_раунда:', f'{Текущий_раунд} -> {Следующий_раунд}')
            # Выдаём карту на стол
                print('Следующий_раунд: ', Следующий_раунд)
                if Следующий_раунд == 'флоп': # если переходим на раунд флоп, то раздём 3 карты
                    # Колода: list[list] = PC.Колода
                    # random.shuffle(Колода) # Перемешиваем колоду если берём из PC.Колода
                    Колода: list[list] = room.Колода
                    a1:list[Any] = Колода.pop()
                    room.обновляем_колоду(Колода)
                    Колода: list[list] = room.Колода
                    a2:list[Any] = Колода.pop()
                    room.обновляем_колоду(Колода)
                    Колода: list[list] = room.Колода
                    a3:list[Any] = Колода.pop()
                    room.обновляем_колоду(Колода)
                    #Карты = [Колода.pop(), Колода.pop(), Колода.pop()]
                    Карты = [a1, a2, a3]
                    room.стол_раздать(Карты)    # устанавливаем три карты для стола ("Карты_стола")
                    print('Карты 1: ', Карты)
                    room.обновляем_колоду(Колода)   # уменьшаем колоду на 3 карты
                elif Следующий_раунд in ['тёрн', 'ривер']: # при переходе к этим раундам выдаёт 1 карту.
                    Колода: list[list] = room.Колода    # тут колода уже перемешенная
                    Карты = [Колода.pop()]      # сохраняет в 'Карты' последний элемент (карту) из 'Колода', и одновременно убирает его из списка колоды
                    room.стол_добавить(Карты)   # добавляем 1 карту к картам стола ("Карты_стола")
                    print('Карты 2: ', Карты)
                    room.обновляем_колоду(Колода)   # уменьшаем колоду на 1 карту
                else: pass
                print('обновляем_колоду: ', Колода)
                return f'Раунд обновлён: {Текущий_раунд} -> {Следующий_раунд}\n'
            else:   # Если это последний раунд
    # Конец игры
                Порядок_ходов: list[int] = room.Порядок_ходов
                Карты_стола: list[list] = room.Карты_стола
                
                Результаты: Dict[int, Dict[str, Any]] = {}  # Словарь для хранения информации о игроках
                Претенденты: Dict[int, Dict[str, Any]] = {} # Лучшая комбинация среди всех игроков
                Макс_сила: int = -1                         # Для сравнения комбинаций
        # ДЛЯ КАЖДОГО ИГРОКА ПРОГОНЯЕМ ЦИКЛ (определяя лучшую комбинацию)
                for ID in Порядок_ходов:    # Основной цикл
                    print(f"ID игрока: {ID}")
                    Игрок = User(ID)
                    Карты_рук: list[list] = Игрок.Карты
                    Карты_комбинации: List[List[Any]]
                    Сила_комбинации: int
                    Карты_комбинации, Сила_комбинации = cls.лучшая_комбинация(Карты_рук, Карты_стола) # Получаем лучшую комбинацию игрока
                # Сохраняем информацию о текущем игроке
                    Результаты[ID] = {
                        "Карты_рук": Карты_рук,
                        "Карты_комбинации": Карты_комбинации,
                        "Сила_комбинации": Сила_комбинации,
                    }
                # Проверка на максимальную силу комбинации
                    if Сила_комбинации > Макс_сила:      # находим игрока с лучшей комбинацией
                        Макс_сила = Сила_комбинации      # у текущего игрока лучшая комбинация среди всех просмотренных
                        Претенденты = {ID: Результаты[ID]}              # заменяем словарь новым, в котором только этот игрок.
                    elif Сила_комбинации == Макс_сила:   # у текущего игрока комбинация совпадает с лучшими
                        Претенденты[ID] = Результаты[ID]                # добавляем его в словарь Претенденты
            # Редактируем БД
                    Комбо: str = PC.названия_комбинаций[Сила_комбинации]
                    Игрок.обновить_комбо(Комбо)     # Наилучшие комбинации и сколько раз выпадали, добавляет +1 к лучшей комбинации (не считается, если игрок вышел чз /покер фолд)
                    Игрок.сброс_ставки()            # 'Сейчас_поставил': 0, 'Всего_поставил': 0, 'Карты': None, "Кол-во_игр": +1 || для победителей карты записаны в отдельном словаре в коде в переменных, а не в БД
                    
                print('Претенденты ', Претенденты)      # {ID: {'Карты_рук': [], 'Карты_комбинации': [], 'Сила_комбинации': 9}}
                # Конец цикла.
                if len(Претенденты) > 1:    # Если есть несколько претендентов, вызываем функцию для сравнения комбинаций:
        # ВЫЗОВ ФУНКЦИИ ПОДСЧЁТА ПОБЕДИТЕЛЕЙ
                    Претенденты = cls.сравнение_комбинаций(Претенденты, Макс_сила)
                    # Претенденты: победителями могут оказаться по итогу сравнения комбинаций как один, так и несколько человек, поэтому после нужна будет ещё одна проверка на кол-во победителей
                else: pass
        # ВЫЗОВ ФУНКЦИИ ПОДСЧЁТА НАГРАД
                банк: int = room.Банк_общий     # room.Банк_общий - сумма приза
                количество_победителей = len(Претенденты)
                # Победитель: Dict[int, Dict[str, Any]] = list(Претенденты.keys())[0]
            # Достаём название комбинации через её силу у первого победителя
                первый_id: int = next(iter(Претенденты))
                Победитель = User(первый_id)
                сила_комбо: int = Претенденты[первый_id]['Сила_комбинации']
                комбинация: str = PC.названия_комбинаций[сила_комбо]
                текст: str = f'**{комбинация}**\n'
                доля: int = банк // количество_победителей  # Округляем вниз
            # Если победили несколько человек
                if количество_победителей > 1:
                    остаток: int = банк % количество_победителей  # Остаток монет
                    текст += "Победители:\n"
                # Назначаем долю каждому победителю
                    for Player_id, данные in Претенденты.items():
                    # Формируем текст для каждого игрока
                        Карты_комбинации = " ".join(card[0] for card in данные['Карты_комбинации'])
                        Карты_рук = " ".join(card[0] for card in данные['Карты_рук'])
                        текст += f"<@{Player_id}> +{доля}\n"
                        текст += f"Комбинация: {Карты_комбинации}\n"
                        текст += f"Карты рук: {Карты_рук}\n\n"
                    # Редактируем БД
                        Победители = User(Player_id)
                        Победители.наградить(доля)              # "Баланс" +доля, "Общий_выигрыш" +доля, "Кол-во_побед" +1
                # Добавляем остаток первому победителю
                    if остаток > 0:
                        Победитель.добавить('Баланс', остаток)  # "Баланс" +остаток только первому игроку (Победитель, а не Победители)
            # Если победил один
                else: 
                # Формируем текст
                    Карты_комбинации = " ".join(card[0] for card in Претенденты[первый_id]['Карты_комбинации'])
                    Карты_рук = " ".join(card[0] for card in Претенденты[первый_id]['Карты_рук'])
                    текст += "Победитель:\n"
                    текст += f"<@{первый_id}> +{доля}\n"
                    текст += f"Комбинация: {Карты_комбинации}\n"
                    текст += f"Карты рук: {Карты_рук}\n\n"
                # Редактируем БД
                    Победитель.наградить(доля)  # Награждаем только одного победителя
                room.сброс_комнаты()            # Сбрасываем у комнаты такие поля, как: 
                room.update_field("Круг", False)# Сбрасываем круг || в методе выше room.сброс_комнаты не сбрасывается круг, т.к. этот метод используется при /фолд, и сброс круга там мог бы вызвать ошибки в игре
        # ОТПРАВКА СООБЩЕНИЯ О ПОБЕДЕ
                текст += '\nПодсказка:\nДля начала новой игры создатель комнаты должен ввести: "/покер начать"'
                await interaction.response.send_message(
                    embed=Embed.комната('Игра окончена!', текст)
                )
                return None  # Завершение функции
        else:   # Если текущего раунда нет в списке
            return f'Ошибка: Текущий раунд "{Текущий_раунд}" не найден в списке!'


# ДУБЛИ: ПАРА, ДВЕ ПАРЫ, СЕТ, ФУЛЛ ХАУС, КАРЕ
    def дубликаты(Карты: List[List[Any]]) -> Tuple[List[List[Any]], int]:
        """
        Определяет дубликаты из списка карт.
        Аргументы:
        Карты: list - список карт, где каждая карта представлена как ['10♠', 'p', 10].
        Возвращает:
        list - список из 5 карт, если комбинация найдена. Пустой список, если нет.
        int - возвращает силу комбинации. Если комбинация не найдена, вернёт 0.
        """
    # Группируем карты по третьему элементу (значению карты)
        Группы_карт: defaultdict[int, List[List[Any]]] = defaultdict(list)
        for Карта in Карты:
            Группы_карт[Карта[2]].append(Карта)
    # Отбираем дубли: пары, тройки, четверки и сортируем по старшинству карт
        Дубли: List[List[List[Any]]] = [group for group in Группы_карт.values() if len(group) > 1]    # Записываем словарь именно с дублями (встречаются больше 1 раза)
        Дубли_Сорт: List[List[List[Any]]] = sorted(Дубли, key=lambda group: group[0][2], reverse=True)  # Сортируем
    # Инициализация переменных
        Комбинация: List[List[Any]] = [] 
        Сила: int = 0
    # Отдельно выделяем пары, тройки и четверки
        Пары: List[List[List[Any]]] = [group for group in Дубли_Сорт if len(group) == 2]  # Только пары
        Тройки: List[List[List[Any]]] = [group for group in Дубли_Сорт if len(group) == 3]  # Только тройки
        Четвёрка: List[List[List[Any]]] = [group for group in Дубли_Сорт if len(group) == 4]  # Только четверки
    # Проверяем комбинации
        if len(Пары) >= 1: # Пара 
            Комбинация = Пары[0]  # Берем первую пару
            Сила = 1
        if len(Пары) >= 2: # Две_пары (может быть три)
            Комбинация = [Пары[0][0], Пары[0][1], Пары[1][0], Пары[1][1]] # Берем две старшие пары
            Сила = 2
        if len(Тройки) >= 1: # Сет
            Комбинация = Тройки[0]  # Берем первую тройку (может быть две)
            Сила = 3
        if len(Пары) >= 1 and len(Тройки) >= 1: # Фулл_Хаус
            Комбинация = [Тройки[0], Пары[0]]  
            Комбинация = [Тройки[0][0], Тройки[0][1], Тройки[0][2], Пары[0][0], Пары[0][1]] # Берем старшую тройку и старшую пару
            Сила = 6
        if Четвёрка: # Каре
            Комбинация = Четвёрка[0]  # Берем старшую четверку
            Сила = 7
    # Возвращаем комбинацию и её силу
        return Комбинация, Сила
    '''
    # Пример использования
    cards: List[List[Any]] = [['6♥', 'c', 6], ['8♠', 'p', 8], ['10♠', 'p', 10], ['Q♥', 'c', 12], ['Q♠', 'p', 12], 
            ['J♠', 'p', 11], ['8♥', 'c', 8], ['J♥', 'c', 11], ['J♥', 'c', 11], ['10♦', 'b', 10], 
            ['8♦', 'b', 8], ['6♣', 'k', 6], ['8♣', 'k', 8]]
    Комбинация: List[List[Any]]
    Сила: int
    Комбинация, Сила = дубликаты(cards)
    '''

# СТРИТЫ: СТРИТ, (СТРИТ ФЛЕШ)
    def стриты(Карты: List[List[Any]]) -> Tuple[List[List[Any]], int]:
        """
        Определяет лучший стрит из списка карт.
        Аргументы:
        Карты: list - список карт, где каждая карта представлена как ['10♠', 'p', 10].
        Возвращает:
        list - список из 5 карт, если комбинация найдена. Пустой список, если нет.
        int - возвращает силу комбинации. Если комбинация не найдена, вернёт 0.
        """
        if len(Карты) < 5:
            return [], 0
        Уникальные_карты = {card[2]: card for card in Карты}.values()       # Убираем дубли (оставляем только уникальные значения по 3-му элементу)
        Отсортированные_карты = sorted(Уникальные_карты, key=lambda card: card[2])   # Сортируем карты по третьему элементу (числовое значение)
    # Проверяем последовательности длиной 5
        Комбинация = []
        Сила: int = 0
        for i in range(len(Отсортированные_карты) - 4): # Достаточно проверить только до len-4
            Стрит = Отсортированные_карты[i:i + 5]      # Берём 5 карт (i и следующие 4 карты)
            if Стрит[-1][2] - Стрит[0][2] == 4:         # Проверяем, образуют ли они последовательность (разница между крайними равна 4)
                if not Комбинация or Стрит[-1][2] > Комбинация[-1][2]: # Если нашли, обновляем лучший стрит
                    Комбинация = Стрит
                    Сила: int = 4
        return Комбинация, Сила


# ФЛЕШИ: ФЛЕШ, СТРИТ ФЛЕШ, ФЛЕШ РОЯЛЬ
    @classmethod
    def флеши(cls, Карты: List[List[Any]]) -> Tuple[List[List[Any]], int]:
        
    #       -----------    ФЛЕШ     -----------
    # 1. Группируем карты по второму элементу
        Группы_карт: defaultdict[str, List[List[Any]]] = defaultdict(list)
        for Карта in Карты:
            Группы_карт[Карта[1]].append(Карта)     # print("Группы_карт: ", Группы_карт) # {'c': [['6♥', 'c', 6], ['7♥', 'c', 7], ...
    # 2. Анализируем группы
        # Инициализация переменных
        Комбинация: List[List[Any]] = [] 
        Все_карты: List[List[Any]] = []
        Сила: int = 0
        for группа in Группы_карт.values():     # Анализируем только группы карт (по каждой букве)
            if len(группа) >= 5:                # Если в группе больше 5 карт
                Все_карты = группа              # Сохраняем все карты одной масти 5+ шт. (нужна для остальных комбинаций: Стрит Флеш и Флеш Рояль)
                Комбинация = sorted(группа, key=lambda x: x[2], reverse=True)[:5]  # Сортируем и берём лучшие 5
                Сила = 5

    #       -----------    СТРИТ ФЛЕШ     -----------
        Комбинация2: List[List[Any]]
        Сила2: int
        Комбинация2, Сила2 = cls.стриты(Все_карты)  # Отправляем Все_карты - список всех карт с одинаковой мастью
        if Сила2 == 4:  # Если в комбинации оказался Стрит-Флеш, то:
            Сила = 8    # Меняем силу комбинации на лучшую (5 -> 8)
            Комбинация = Комбинация2            # Меняем комбинацию на лучшую (Флеш -> Стрит-Флеш)

    #       -----------    ФЛЕШ РОЯЛЬ     -----------
        if  any(Карта[2] == 14 for Карта in Комбинация2):   # Если сила любой карты в комбинации Стрит Флеша = 14, то у нас Флеш Рояль
            Сила = 9    # Меняем силу комбинации на лучшую (5 -> 9)

        return Комбинация, Сила


# ПОИСК ЛУЧШЕЙ КОМБИНАЦИИ
    @classmethod
    def лучшая_комбинация(cls, Карты_рук: List[List[Any]], Карты_стола: List[List[Any]]) -> Tuple[List[List[Any]], int]:
        #       -----------    ПЕРВАЯ И ВТОРАЯ СТАРШАЯ КАРТА  -----------
        Карты_все = Карты_стола + Карты_рук

        #       -----------    ДУБЛИ: ПАРА, ДВЕ ПАРЫ, СЕТ, ФУЛЛ ХАУС, КАРЕ     -----------
        Комбинация2: List[List[Any]]
        Сила2: int
        Комбинация2, Сила2 = cls.дубликаты(Карты_все)
        '''
        print("Комбинация 2:", Комбинация2)
        print("Сила 2:", Сила2)
        '''
        #       -----------    СТРИТЫ     -----------
        Комбинация3: List[List[Any]]
        Сила3: int
        Комбинация3, Сила3 = cls.стриты(Карты_все)
        '''
        print("Комбинация 3:", Комбинация3)
        print("Сила 3:", Сила3)
        '''    
        #       -----------    ФЛЕШИ: ФЛЕШ, СТРИТ ФЛЕШ, ФЛЕШ РОЯЛЬ     -----------
        Комбинация4: List[List[Any]]
        Сила4: int
        Комбинация4, Сила4 = cls.флеши(Карты_все)
        '''
        print("Комбинация 4:", Комбинация4)
        print("Сила 4:", Сила4)
        '''
    # Определяем наилучшую комбинацию:
        # Собираем комбинации и их силы
        Все_комбинации = [
            (Карты_рук, 0), # комбинация - старшая карта (комбинация = Карты_рук, сила = 0)
            (Комбинация2, Сила2),
            (Комбинация3, Сила3),
            (Комбинация4, Сила4)
        ]
        Лучшая_комбинация = max(Все_комбинации, key=lambda x: x[1])         # Выбираем комбинацию с наибольшей силой
        Карты_комбинации: List[List[Any]]
        Сила_комбинации: int
        Карты_комбинации, Сила_комбинации = Лучшая_комбинация # Разбиваем результат на карты и силу
        # Вывод результата
        # print("Лучшая комбинация:")
        print(f"Карты: {Карты_комбинации}")
        print(f"Название: {PC.названия_комбинаций[Сила_комбинации]}")
        return Карты_комбинации, Сила_комбинации


# ПОИСК ЛУЧШЕГО ИГРОКА (среди игроков с одинаковыми комбинациями)
    @classmethod
    def сравнение_комбинаций(cls, Претенденты: Dict[int, Dict[str, Any]], Сила: int) -> Dict[int, Dict[str, Any]]:
        """
        Сравнивает комбинации игроков с одинаковой силой.
        Возвращает ID победителя.

        Если у нескольких человек одинаковая комбинация, вызываем эту функцию. 
        Здесь проверяем, какая, и сравниваем её / кикеров (старшие карты) по обстоятельствам.
        """
        match Сила:
            case 0:  # Старшая карта
                return cls.сравнить_старшие_карты(Претенденты)
            case 1 | 3 | 7:  # Пара, Сет, Каре
                return cls.сравнить_пара_сет_каре(Претенденты)
            case 2 | 6:  # Две пары, Фулл Хаус
                return cls.сравнить_две_пары_фулл_хаус(Претенденты)
            case 4 | 5 | 8 | 9:  # Стрит, Флеш, Стрит Флеш, Флеш Рояль
                return cls.сравнить_стрит_и_флеш(Претенденты)


# Сравнивает старшие карты, используется в: Пара, Сет, Каре, Две пары, когда комбинации равны, а также если комбинаций нет у всех игроков
    def сравнить_старшие_карты(Претенденты: Dict[int, Dict[str, List[List[Any]]]]) -> Dict[int, Dict[str, List[List[Any]]]]:
        # Проверяем длину списка 'Карты_рук' у первого игрока
        оставшиеся_карты = len(list(Претенденты.values())[0]["Карты_рук"])
        Сила_комбинации = list(Претенденты.values())[0]["Сила_комбинации"]    # Сила_комбинации у первого участника (Силы комбинаций у всех равны)
    # Если в комбинации ДВЕ ПАРЫ, то сравнивать две карты на руках не надо, только одну (в сумме должно быть 5 карт):
        if (оставшиеся_карты == 2) and (Сила_комбинации != 2):
        # Сравниваем первые карты по силе среди всех игроков
            максимальная_первая_карта = max(
                данные['Карты_рук'][0][2] for данные in Претенденты.values()
            )
        # Удаляем игроков, у которых первая карта меньше максимальной
            Претенденты = {
                id: данные for id, данные in Претенденты.items()
                if данные['Карты_рук'][0][2] == максимальная_первая_карта
            }
        # если осталось 2 и более игроков, удаляем первую карту, чтобы позже сравнить вторую (оставшуюся)
            if len(Претенденты) > 1: 
                for данные in Претенденты.values():
                    данные['Карты_рук'].pop(0)  # Удаляем первую карту
                # print('Претенденты 0 ', Претенденты)
            else: return Претенденты
    # Если длина изначально = 1, то сразу перейдём сюда:
        # Сравниваем единственные карты по силе среди оставшихся игроков
        максимальная_карта = max(
            данные['Карты_рук'][0][2] for данные in Претенденты.values()
        )
        # Удаляем игроков, у которых карта меньше максимальной
        Претенденты = {
            id: данные for id, данные in Претенденты.items()
            if данные['Карты_рук'][0][2] == максимальная_карта
        }
        return Претенденты


# Сравнивает Пара, Сет, Каре
    @classmethod
    def сравнить_пара_сет_каре(cls, Претенденты: Dict[int, Dict[str, Any]]) -> Dict[int, Dict[str, Any]]:
        """
        Args:
            Претенденты: Словарь участников вида {ID: данные игрока}.

        Returns:
            Модифицированный словарь 'Претенденты'.
        """
        # Ищем максимальное третье первой карты (первой карты, т.к. значения в парах одинаковые) значение среди всех участников
        максимальное_значение: int = max(
        данные["Карты_комбинации"][0][2] 
        for данные in Претенденты.values()
        )
    # Фильтруем участников, у которых есть максимальное третье значение
        Претенденты_с_максимумом = {
            id: данные for id, данные in Претенденты.items()
            if any(карта[2] == максимальное_значение for карта in данные["Карты_комбинации"])
        }
    # Если осталось больше одного игрока, то сравниваем кикеры
        if len(Претенденты_с_максимумом) > 1:
        # Удаляем карты из 'Карты_рук', которые есть в 'Карты_комбинации'
            for данные in Претенденты_с_максимумом.values():
                данные["Карты_рук"] = [карта for карта in данные["Карты_рук"] if карта not in данные["Карты_комбинации"]]
            '''
            Получаем количество оставшихся карт у первого участника 
        у всех участников кол-во оставшихся карт будет равно, т.к.:
        пара одинаковой силы может быть у трёх человек или меньше (если на столе 1 карта, и у участников такая же  - другой масти) 
        или может быть пара на столе, тогда сверяем две старших карты.
        могут быть пары одинаковой силы у двух игроков на руках. Тогда ничья.
            '''
            оставшиеся_карты = len(list(Претенденты_с_максимумом.values())[0]["Карты_рук"])
        # В зависимости от количества оставшихся карт вызываем проверку кикеров (если они не входили в Карты_комбинации, т.е. len(оставшиеся_карты) > 0)
            if оставшиеся_карты > 0:  # Используем конструкцию case-match
                return cls.сравнить_старшие_карты(Претенденты_с_максимумом)
            else: return Претенденты_с_максимумом
        else: return Претенденты_с_максимумом


# Сравнивает Две пары и Фулл Хаус
    @classmethod
    def сравнить_две_пары_фулл_хаус(cls, Претенденты: Dict[int, Dict[str, Any]]) -> Dict[int, Dict[str, Any]]:
        # Ищем максимальное третье первой карты (первой карты, т.к. значения в парах одинаковые) значение среди всех участников
        максимальное_значение: int = max(
        данные["Карты_комбинации"][0][2] 
        for данные in Претенденты.values()
        )
    # Оставляем участников, у которых есть максимальное третье значение
        Претенденты_с_максимумом = {
            id: данные for id, данные in Претенденты.items()
            if any(карта[2] == максимальное_значение for карта in данные["Карты_комбинации"])
        }
    # Если осталось больше одного игрока, то сравниваем вторую пару (если две пары) или тройку (если фулл хаус)
        if len(Претенденты_с_максимумом) > 1:
            # Ищем максимальное третье четвёртой карты (четвёртой [3], т.к. значения в парах/тройках одинаковые) значение среди всех участников
            # в фулл хаусе сначала идёт тройка, потом пара. И надо сравнивать сначала тройки, лишь потом пары
            максимальное_значение_2: int = max(
            данные["Карты_комбинации"][3][2] 
            for данные in Претенденты.values()
            )
        # Оставляем участников, у которых есть максимальное третье значение
            Претенденты_с_максимумом_2 = {
                id: данные for id, данные in Претенденты_с_максимумом.items()
                if any(карта[2] == максимальное_значение_2 for карта in данные["Карты_комбинации"])
            }
        else: return Претенденты_с_максимумом
    # если у нас фулл хаус, кикеры не смотрим (всего 5 карт в комбинации уже задуйствовано) или остался 1 человек
        Сила_комбинации = list(Претенденты_с_максимумом_2.values())[0]["Сила_комбинации"]    # Сила_комбинации у первого участника (Силы комбинаций у всех равны)
        if (Сила_комбинации == 6) or (len(Претенденты_с_максимумом_2) == 1):
            return Претенденты_с_максимумом_2
        else:   # во все остальные случаи должны входить две пары, где осталось больше 1 игрока => проверяем кикеры (старшие карты)
        # Удаляем карты из 'Карты_рук', которые есть в 'Карты_комбинации'
            for данные in Претенденты_с_максимумом_2.values():
                данные["Карты_рук"] = [карта for карта in данные["Карты_рук"] if карта not in данные["Карты_комбинации"]]
            '''
            Получаем количество оставшихся карт у первого участника 
        у всех участников кол-во оставшихся карт будет равно, т.к.:
        для двух пар либо один победитель (на столе пара и карты для второй пары каждому игроку, на руках у игроков несдотающие карты для двух пар - 
        - в таком случае у одного из них две пары будут старше, если больше вторая карта на руках)
        либо две пары лежат на столе, тогда оцениваются обе старшие карты у каждого игрока.

        для фулл хауса комбинация из 5 карт уже собрана ранее
            '''
            оставшиеся_карты = len(list(Претенденты_с_максимумом_2.values())[0]["Карты_рук"])
        # В зависимости от количества оставшихся карт вызываем проверку кикеров (если они не входили в Карты_комбинации, т.е. len(оставшиеся_карты) > 0)
            if оставшиеся_карты > 0:
                return cls.сравнить_старшие_карты(Претенденты_с_максимумом_2)
            else: return Претенденты_с_максимумом_2


# Сравнивает Стрит, Флеш, Стрит Флеш, Флеш Рояль
    def сравнить_стрит_и_флеш(Претенденты: Dict[int, Dict[str, Any]]) -> Dict[int, Dict[str, Any]]:
        """
        Функция сравнивает карты из 'Карты_комбинации' для каждого участника, 
        оставляя только тех, у кого наибольшее третье значение среди всех участников.
        Args:
            Претенденты: словарь участников, содержащий их карты, лучшую комбинацию и её силу.
        
        Returns:
            Отфильтрованный словарь Претендентов с максимальной силой карт.
        """
    # Ищем максимальное третье значение среди всех участников
        максимальное_значение: int = max(
            max(карта[2] for карта in данные["Карты_комбинации"])
            for данные in Претенденты.values()
        )
    # Фильтруем участников, у которых есть максимальное третье значение
        Претенденты_с_максимумом = {
            id: данные for id, данные in Претенденты.items()
            if any(карта[2] == максимальное_значение for карта in данные["Карты_комбинации"])
        }
        return Претенденты_с_максимумом


async def setup(bot: commands.Bot) -> None:
    await bot.add_cog(Embed(bot))